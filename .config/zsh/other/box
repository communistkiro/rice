#!/bin/zsh
box () {
((# > 0)) || return 0;
typeset a d h B T H tl tr bl br th bh lv rv r w; 
typeset -i s;
s=1;
while { getopts 's:h:B:T:H:' a } { case $a {
  (s) # line style
    ((OPTARG >= 1 && OPTARG < 5)) && s=$OPTARG;;
  (h) # header
    h=${OPTARG};;
  (B) # box color
    B='\033[0;'$(printf '%s' ${OPTARG} | perl -pe 's/([0-7])/3$1;/g; s/i/7;/gi; s/b/1;/gi; s/;$//')m;;
  (T) # text color
    T='\033[0;'$(printf '%s' ${OPTARG} | perl -pe 's/([0-7])/3$1;/g; s/i/7;/gi; s/b/1;/gi; s/;$//')m;;
  (H) # header color
    H='\033[0;'$(printf '%s' ${OPTARG} | perl -pe 's/([0-7])/3$1;/g; s/i/7;/gi; s/b/1;/gi; s/;$//')m;;
(*) less -F << HEREDOC # help wanted.
NAME
  box - enclose strings in box

SYNOPSIS
  box [-s 1--4] [-B [0-7][i|I][b|B]] [-T [0-7][i|I][b|B]] [-H [0-7][i|I][b|B]] [-h header <string>] [string(s)]

DESCRIPTION
  box is a zsh script that encloses one or more strings, extending to 4 above the lengthiest 
  string, header included. The box's style is given by '-s', and may be thick, thin, double, 
  or dotted; may have a title; and may color the box's line, text, and header in different 
  colors according to ANSI C escape codes. The color is a 1--3-character sequence of a number 
  0--7, 'b|B' for bold color, and 'i|I' to switch fore- and background colors. The number 
  corresponds to the colors black, red, green, yellow, blue, magenta, cyan, and white, as 
  defined for your terminal emulator. Defaults to thick lines and white for box, text, and 
  header.

EXAMPLES
    box -h header 'This is a sentence on the first row' 'This is a second row'

    a=Zz; box -s 3 -T 3b -B b2 -H 5i -h 'looooooooooooooooong snooze' ${(pr.16..$a.l.8...)a} "padding works, too"

HEREDOC
return 1;;
}; };

((# + 1 > OPTIND)) || return 0;

tl=${$(<<<'┏ ┌ ╔ ⡏')[s]}; # top left
bl=${$(<<<'┗ └ ╚ ⣇')[s]}; # bottom left
tr=${$(<<<'┓ ┐ ╗ ⢹')[s]}; # top right
br=${$(<<<'┛ ┘ ╝ ⣸')[s]}; # bottom right
th=${$(<<<'━ ─ ═ ⠉')[s]}; # top horizontal
bh=${$(<<<'━ ─ ═ ⣀')[s]}; # bottom horizontal
lv=${$(<<<'┃ │ ║ ⡇')[s]}; # left vertical
rv=${$(<<<'┃ │ ║ ⢸')[s]}; # right vertical
# box inside width
w=${${(On)@[OPTIND,-1]//(#m)*/${#MATCH}}[1]};
(($+h)) && {
  h=$(tr '\n\t\r\f' ' ' <<< $h)
  (($#h > w)) && w=$(($#h + 4));
};

if ((w + 2 > COLUMNS)) {
  # FIXME; IF HEADER MULTI ROW OR LONGER THAN COLUMNS ... ELSE
  (($+h)) &&
#   if ((${#${h//[^$'\n']/}} > 0)) {
#   } elif (($#h > COLUMNS - 4)) {
#   } else {
    printf '%b%s%s%b%s%b%s%s\n' $B $tl ${(pr.(COLUMNS-2-$#h)/2..$th.)} $H $h $B ${(pr.(COLUMNS-2-$#h)/2+$#h+COLUMNS-2-($#h+COLUMNS-2)/2*2..$th.)} $tr
#   };
    printf '%b%s%s%s\n' $B $tl ${(pr.COLUMNS-3..$th.)} $tr;
  for a ( $@[OPTIND,-1] ) {
    # for d ( ${(f)"$(fmt -w $COLUMNS <<< $a)"} ) {
    for d ( ${(f)"$(<<<$a)"} ) {
      printf '%s %b%s%b %s\n' $lv $T ${(r.COLUMNS-4.)d} $B $rv;
    };
  };
  printf '%s%s%s%b\n' $bl ${(pr.COLUMNS-2..$bh.)} $br '\033[0m';
} else {
  (($+h)) &&
    printf '%b%s%s%b%s%b%s%s\n' $B $tl ${(pr.(w-$#h)/2..$th.)} $H $h $B ${(pr.(w-$#h)/2+$#h+w-($#h+w)/2*2..$th.)} $tr ||
    printf '%b%s%s%s\n' $B $tl ${(pr.w-1..$th.)} $tr;
  for a ( $@[OPTIND,-1] ) { printf '%s %b%s%b %s\n' $lv $T ${(r.w-2.)a} $B $rv };
  printf '%s%s%s%b\n' $bl ${(pr.w..$bh.)} $br '\033[0m';
};
}
