#!/bin/sh

function tmr() {
# countdown timer + alarm, rework of Joe Standring <git@joestandring.com> scripts; support times of up to 4.1667 days
local alarm=~/.local/CartoonFoghorn.m4a;
local a=0;
local p=0;
local o w b d h m s D H M S r t
while getopts 'aph' o; do
    case $o in
        a) a=1;;
        p) p=1;;
        h) ;&
        *) 
less -F <<HEREDOC
NAME
    tmr - a countdown/alarm script    

SYNOPSIS
    tmr [-a] ...
        [-p] [minutes minutes]
        [days hours minutes seconds]
        [days hours minutes]
        [hours minutes]
        [minutes]

DESCRIPTION
    Start a countdown, set up an alarm, or start a pomodoro session from the given time 
    paramters, and play an audio file on completion. Days are always relative to today's, 
    i.e., 1 is tomorrow, or +24h. For coundowns. negatives values are parsed as corrections, 
    for alarms, because the day is relative, a future alarm is always set unless all values 
    are zero (default, if given empty string). All values are integers. Months don't coming 
    into play in tmr. Default cycle count, work-, and break-section durations can be editted 
    in the script.

CONTROLS
    SIGINT (^c) to pause; SIGQUIT (^\) to quit.
    
EXAMPLES
    An alarm for 00:55:57 on the 8. days after today
        tmr -a 7 26 -61 -183

    An alarm for midnight
        tmr -a 1 0 0;

    An alarm for 22:57:59 tonight, or tomorrow, depending on current time
        tmr -a 1 -1 -1 -1

    An alarm for 00:06:34
        tmr -a 7 -26

    An alarm for the next time the minutes are 26
        tmr -a 26

    A 59-minute, 59-second countdown
        tmr 1 0 -1

    A 45-minute countdown
        tmr 45

    Negative final value, just returns; preprend negative first arguments w/ --
        tmr -- -1 

    A 3-cycle pomodoro sesh with 45-minute work-, and 8-minute break-sections
        tmr -p

    A 3-cycle pomodoro sesh with 30-minute work-, and 10-minute break-sections
        tmr -p 30 10

EXIT STATUS
    0
        on successfully completed countdown or alarm.
    1
        if all values are zero, and/or corrections yield a value in the past.
    2
        on quitting.
BUGS
    Please report any aberrant behavior or bugs to vlg@tutamail.com


HEREDOC
        return 1;;
    esac
done
shift $((OPTIND-1));

if [ $p -eq 1 ]; then
    if [ $# -eq 2 ]; then
        w=$1;
        b=$2;
        [ $w -le 0 ] || [ $b -le 0 ] && return 1;
    else
        w=45;
        b=8;
    fi
    for a in $(seq 3); do
        clear; printf "Starting %d. pomodoro cycle\nWork!\n" $a;
        tmr $w; [ $? -eq 2 ] && break;
        printf '\aBreak!\n'; tmr $b;[ $? -eq 2 ]; printf '\a'; break; 
    done
    return $?;
fi

# tmp file storing current remaining time
# tmp=$(mktemp /tmp/countdown.XXXXXX);
tmp="/tmp/tmr.tmr.tmr";

if [ $# -eq 4 ]; then
    d=$1;
    h=$2;
    m=$3;
    s=$4;
elif [ $# -eq 3 ]; then
    d=$1;
    h=$2;
    m=$3;
elif [ $# -eq 2 ]; then
    h=$1;
    m=$2;
elif [ $# -eq 1 ]; then
    m=$1;
else
    echo "Set alarm $([ $a -eq 1 ] && echo at || echo in):";
    # sh
    # read -r -p 'days (rel. not abs.): ' d
    # read -r -p 'hours: ' h
    # read -r -p 'minutes: ' m
    # read -r -p 'seconds: ' s
    # zsh
    read -r d\?'days (rel. not abs.): '
    read -r h\?'hours: '
    read -r m\?'minutes: '
    read -r s\?'seconds: '
fi

[ "$d" = '' ] && d=0;
[ "$h" = '' ] && h=0;
[ "$m" = '' ] && m=0;
[ "$s" = '' ] && s=0;
[ "$d" -eq 0 ] && [ "$h" -eq 0 ] && [ "$m" -eq 0 ] && [ "$s" -eq 0 ] && return 1;

for r in $d $h $m $s; do
case $r in *[!0-9-]*) echo "Non-integer value!"; return 1;; esac
done

if [ $a -eq 1 ]; then
    # -59 <= s <= 59; -59 <= m <= 59; -24 <= h <= 24; 0 <= d
    m=$((m + s / 60)); s=$((s % 60));
    h=$((h + m / 60)); m=$((m % 60));
    d=$((d + h / 24)); h=$((h % 24)); 
    
    S=$(date +%S);
    M=$(date +%M);
    H=$(date +%H);

    if   [ $S -ge $s ] && [ $m -eq 0 ] && [ $h -eq 0 ] && [ $d -eq 0 ]; then m=$((M + 1)); h=$((H));
    elif [ $M -gt $m ] || ([ $M -eq $m ] && [ $S -ge $s ]) && [ $h -eq 0 ] && [ $d -eq 0 ]; then h=$((H + 1));
    elif [ $M -lt $m ] && [ $h -eq 0 ] && [ $d -eq 0 ]; then h=$H;
    elif [ $H -gt $h ] || ([ $H -eq $h ] && [ $M -ge $m ]) && [ $d -eq 0 ]; then d=$((d + 1));
    fi;

    [ $d -lt 0 ] || [ $((60 * (60 * (24 * d + h) + m) + s)) -lt 0 ] && return 1;

    t=$(date -d "$(date +%Y-%m-%d) +${d}days +${h}hours +${m}minutes +${s}seconds" '+%Y-%m-%d %H:%M:%S');
    printf "Alarm set for %s.\n" "$t";

    t=$(($(date -d "$(date +%Y-%m-%d) +${d}days ${h}hours +${m}minutes +${s}seconds" '+%s') - $(date +%s)));
else;
    t=$((60 * (60 * (24 * d + h) + m) + s)); [ $t -lt 0 ] && return 1;
fi;

trap 'rm -f "$tmp"; trap - QUIT; return 2;' QUIT HUP
trap 'a=$((a * -1));' INT

unset d h m s r; a=1;
# output remainind time left as HH:MM:SS to stdout and tmpfile
while [ $t -ge 0 ]; do
    if [ $a -eq 1 ]; then
        printf "%02d:%02d:%02d\n" $((t/3600)) $((t%3600/60)) $((t%60));
        printf "%02d:%02d:%02d\n" $((t/3600)) $((t%3600/60)) $((t%60)) > $tmp;
        t=$((t - 1));
    fi;
    sleep 1;
done

if [ $? -eq 0 ] && mpc status &>/dev/null | pcre2grep -q 'playing'; then 
    mpc -q toggle; mpv --no-config --really-quiet $alarm; mpc -q toggle; 
else 
    mpv --really-quiet $alarm;
fi

rm -f $tmp;
}