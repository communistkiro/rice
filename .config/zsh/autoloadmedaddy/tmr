#!/bin/zsh

function tmr() {
# countdown timer + alarm, rework of Joe Standring <git@joestandring.com> scripts; support times of up to 4.1667 days
# local alarm=~/.local/CartoonFoghorn.m4a;
local o tmp;
integer w b d h m s D H M S r t;
while getopts 'ap' o; do
    case $o in
        (a) local a;;
        (p) local p;;
        (*) 
less -F <<HEREDOC
NAME
    tmr - a countdown/alarm script    

SYNOPSIS
    tmr [-a] ...
        [-p] [minutes minutes]
        [days hours minutes seconds]
        [days hours minutes]
        [hours minutes]
        [minutes]

DESCRIPTION
    Start a countdown, set up an alarm, or start a pomodoro session from the given time 
    paramters, and play an audio file on completion. Days are always relative to today's, 
    i.e., 1 is tomorrow, or +24h. For coundowns. negatives values are parsed as corrections, 
    for alarms, because the day is relative, a future alarm is always set unless all values 
    are zero (default, if given empty string). All values are integers. Months don't come  
    into play in tmr. Default cycle count, work-, and break-section durations can be editted 
    in the script. Given no arguments, it prompt for the days, hours, minutes, seconds for 
    the alarm or countdown separately.

CONTROLS
    SIGINT (^c) to pause; SIGQUIT (^\) to quit.
    
EXAMPLES
    An alarm for 00:55:57 on the 8. days after today
        tmr -a 7 26 -61 -183

    An alarm for midnight
        tmr -a 1 0 0;

    An alarm for 22:57:59 tonight, or tomorrow, depending on current time
        tmr -a 1 -1 -1 -1

    An alarm for 00:06:34
        tmr -a 7 -26

    An alarm for the next time the minutes are 26
        tmr -a 26

    A 59-minute, 59-second countdown
        tmr 1 0 -1

    A 45-minute countdown
        tmr 45

    Negative final value, just returns; preprend negative first arguments w/ --
        tmr -- -1 

    A 3-cycle pomodoro sesh with 45-minute work-, and 8-minute break-sections
        tmr -p

    A 3-cycle pomodoro sesh with 30-minute work-, and 10-minute break-sections
        tmr -p 30 10

EXIT STATUS
    0
        on successfully completed countdown or alarm.
    1
        if all values are zero, and/or corrections yield a value in the past.
    2
        on quitting.
BUGS
    Please report any aberrant behavior or bugs to vlg@tutamail.com


HEREDOC
return 1;; esac; shift $((OPTIND-1)); done;

if ((${+p})); then
    if (($# == 2)); then
        (($1 < 0)) || (($2 < 0)) && return 1;
        w=$1;
        b=$2;
    else
        w=45;
        b=8;
    fi
    for a in $(seq 3); do
        clear; printf '\aStarting %d. pomodoro cycle\nWork!\n' $a;
        tmr $w; (($? == 2)) && break;
        clear; printf '\aBreak!\n'; tmr $b; (($? == 2)) && break; 
    done
    return $?;
fi

tmp=/tmp/tmr.tmr.tmr;

if   (($# == 4)); then
    d=$1; h=$2; m=$3; s=$4;
elif (($# == 3)); then
    d=$1; h=$2; m=$3;
elif (($# == 2)); then
          h=$1; m=$2;
elif (($# == 1)); then
                m=$1;
else
    ((${+a})) && printf 'Set alarm for\n' || printf 'Set countdown for '
    read 'd?days (rel. not abs.): ';
    read 'h?hours: ';
    read 'm?minutes: ';
    read 's?seconds: ';
fi

[[ $d = '' ]] && d=0;
[[ $h = '' ]] && h=0;
[[ $m = '' ]] && m=0;
[[ $s = '' ]] && s=0;
((d == 0)) && ((h == 0)) && ((m == 0)) && ((s == 0)) && return 1;

if ((${+a})); then
    m=$((m + s / 60)); s=$((s % 60));
    h=$((h + m / 60)); m=$((m % 60));
    d=$((d + h / 24)); h=$((h % 24)); 
    
    S=$(date +%S);
    M=$(date +%M);
    H=$(date +%H);

    if ((S >= s)) && ((m == 0)) && ((h == 0)) && ((d == 0)); then m=$((M + 1)); h=$H;
    elif ((M > m)) || { ((M == m)) && ((S >= s)) } && ((h == 0)) && ((d == 0)); then h=$((H + 1));
    elif ((M < m)) && ((h == 0)) && ((d == 0)); then h=$H;
    elif ((H > h)) || { ((H == h)) && ((M >= m)) } && ((d == 0)); then ((d += 1)); fi;

    ((d < 0)) || ((60 * (60 * (24 * d + h) + m) + s < 0)) && return 1;

    t=$(date -d "$(date +%Y-%m-%d) +${d}days +${h}hours +${m}minutes +${s}seconds" '+%Y-%m-%d %H:%M:%S');
    printf "\nAlarm set for %s.\n" "$t";

    t=$(($(date -d "$(date +%Y-%m-%d) +${d}days ${h}hours +${m}minutes +${s}seconds" '+%s') - $(date +%s)));
else;
    t=$((60 * (60 * (24 * d + h) + m) + s)); (($t < 0)) && return 1;
fi;

trap 'rm -f "$tmp"; trap - QUIT; return 2;' QUIT HUP
trap 'a=$((a * -1));' INT

unset d h m s r; a=1;
# output remainind time left as HH:MM:SS to stdout and tmpfile
while ((t >= 0)); do
    if ((a == 1)); then
        printf "%02d:%02d:%02d\n" $((t/3600)) $((t%3600/60)) $((t%60)) | tee $tmp;
        ((t -= 1));
    fi;
    sleep 1;
done

if (($? == 0)) && mpc status &>/dev/null | pcre2grep -q playing; then 
    # mpc -q toggle; mpv --no-config --really-quiet $alarm; mpc -q toggle; 
    mpc -q toggle; beep -f 200 -r 3 -l 300 -n -l300 -r3 -f $((200*27/18)); mpc -q toggle; 
else 
    # mpv --really-quiet $alarm;
    beep -f 200 -r 3 -l 300 -n -l 300 -r 3 -f $((200*27/18));
fi

rm -f $tmp;
}