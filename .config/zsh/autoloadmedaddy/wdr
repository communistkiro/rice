#!/bin/zsh

function menu () {
  local m t a z;
  while getopts 'm:t:' a; do case $a in
  (m) m=$(printf "\033[3$(pcre2grep -o1 '([0-7])' <<< ${OPTARG} || <<< 7)$(pcre2grep -qio1 'b' <<< ${OPTARG} && <<< ';1')m"); ((z+=2));;
  (t) t=$(printf "\033[3$(pcre2grep -o1 '([0-7])' <<< ${OPTARG} || <<< 7)$(pcre2grep -qio1 'b' <<< ${OPTARG} && <<< ';1')m"); ((z+=2));;
  esac; done; ((z+=1));
  (($+m)) || m=$(printf '\033[0m');
  (($+t)) || t=$(printf '\033[0m');
  for a in $@[$z,-1]; do printf '%s%4s    %s%s\n' $m ${a%% *} $t ${a#* }; done; printf '\033[0m';
}

function box () {
  (($# == 0)) && return 0;
  local a h B T H ul ur dl dr uh dh lv rv z r; integer s=1;
  while getopts 'l:h:B:T:H:' a; do case $a in
    (l) ((5 > OPTARG > 0)) && s=${OPTARG} && ((z+=2));; # line style
    (h) h=${OPTARG}; ((z+=2));; # header
    (B) B=${OPTARG}; ((z+=2));; # box color
    (T) T=${OPTARG}; ((z+=2));; # text color
    (H) H=${OPTARG}; ((z+=2));; # header color
  esac; done; unset a; ((z+=1));

  B='\033[3'"$(pcre2grep -o1 '([0-7])' <<< $B || <<< 7)$(pcre2grep -qio1 'b' <<< $B && <<< ';1')m";
  T='\033[3'"$(pcre2grep -o1 '([0-7])' <<< $T || <<< 7)$(pcre2grep -qio1 'b' <<< $T && <<< ';1')m";
  H='\033[3'"$(pcre2grep -o1 '([0-7])' <<< $H || <<< 7)$(pcre2grep -qio1 'b' <<< $H && <<< ';1')m";
  r='\033[0m'

  ul=(┏ ┌ ╔ ⡏); ul=${ul[$s]};
  dl=(┗ └ ╚ ⣇); dl=${dl[$s]};
  ur=(┓ ┐ ╗ ⢹); ur=${ur[$s]};
  dr=(┛ ┘ ╝ ⣸); dr=${dr[$s]};
  uh=(━ ─ ═ ⠉); uh=${uh[$s]};
  dh=(━ ─ ═ ⣀); dh=${dh[$s]};
  lv=(┃ │ ║ ⡇); lv=${lv[$s]};
  rv=(┃ │ ║ ⢸); rv=${rv[$s]};

  s=0; for a in $@[$z,-1]; do [[ ${(c)#a} -gt $s ]] && s=${(c)#a}; done; 
  if ((${+h})) && [[ $#h -gt $s ]]; then s=$#h; ((s+=2)); fi; ((s+=2)); 


  ((${+h})) && printf "$B$ul${(pr.(((s-$#h)/2))..$uh.)uh}$r$H$h$r$B${(pr.(((s-$#h)/2+$#h+s-($#h+s)/2*2))..$uh.)uh}$ur\n" || printf "$B$ul${(pr.((s-1))..$uh.)uh}$ur\n";

  for a in $@[$z,-1]; do printf "$lv $r$T${(r.((s-2)).. .)a} $r$B$rv\n"; done;

  printf "$dl${(pr.$s..$dh.)dh}$dr$r\n";
}

function () {
  if ! ping -c 1 63.42.42.155  &>/dev/null; then read -k1 '?No internet connection!'; return 1; fi;
  setopt extended_glob; # no_sh_glob ksh_glob;
  clear;
  menu -m 4b -t 2 '1 openweathermap' '2 darksky' 'q exit';
  case $(read -sek1) in
    (1) # OPENWEATHERMAP    https://openweathermap.org/api/
      local c d lon lat loc weather api_key api_call;
      while true; do
        clear; box -H 1b -B 4 -T 3 -h openweathermap \
          "${(r.16..)$(<<< lon/lat:)}${lon:--} / ${lat:--}" \
          "${(r.16..)$(<<< location:)}${loc:-Sofia,Bulgaria}" \
          "${(r.16..)$(<<< options:)}${${c:+current}:-48h}; ${${d:+descriptions}:-plots}";
        menu -m 4b -t 2 '1 longitude / latitude' '2 location' '3 current / 48h' '4 descriptions / plots' '5 go' 'q quit';
        case $(read -sek1) in
          (1) read 'lon?lon: '; read 'lat?lat: '; if [[ ! ${lon} =~ '^\d+\.?\d\+$' ]] || [[ ! ${lat} =~ '^\d+\.?\d+$' ]]; then read -sek 'Invalid input!'; unset lon lat; return 1; fi;;
          (2) read 'loc?location: '; loc=${loc// /%20};;
          (3) ((${+c})) && unset c || local c;;
          (4) ((${+d})) && unset d || local d;;
          (5)
            if which curl &>/dev/null; then alias fetch='curl -s -f -L --max-redirs 0  -H "User-Agent:"'; elif which wget &>/dev/null; then alias fetch='wget -qO -'; else return 1; fi;
            api_key=85a4e3c55b73909f42c6a23ec35b7147;
            api_call=weather;

            if ((${+lat})) && ((${+lon})); then
              if ! weather="$(fetch "api.openweathermap.org/data/2.5/onecall?lat=${lat}&lon=${lon}&appid=${api_key}&units=metric")"; then read -sk1 '?Sum Ting Wong!'; return 22; fi; 
            elif ((${+loc})); then 
              if ! weather=$(fetch "api.openweathermap.org/data/2.5/${api_call}?q=${loc:-Sofia,Bulgaria}&appid=${api_key}&units=metric"); then read -sk1 '?Sum Ting Wong!'; return 23; fi; 
            fi;

            [[ -z ${wea} ]] && read -sk1 '?Cannot fetch weather data.' && return 69;
            (($(jq -r '.cod' <<< ${wea} 2>/dev/null) != 200)) && read -sk1 '?Cannot fetch weather data for the given location.' && return 75;

            if ((${+c} > ${+d})); then
              jq -r . <<< ${wea}; return 0;
            elif ((${+c} == ${+d})) && (($+c)); then
              jq -r '.weather[].description' <<< ${wea} | column ; return 0;
            fi;

            ((${+lat})) || lat=$(jq -r '.coord.lat' <<< ${wea});
            ((${+lon})) || lon=$(jq -r '.coord.lon' <<< ${wea});

            api_call=onecall;
            weather="$(fetch "api.openweathermap.org/data/2.5/${api_call}?lat=${lat}&lon=${lon}&appid=${api_key}&units=metric")" || return 24;

            if ((${+d})); then
              d=(${(@f)"$(jq -r '.hourly[].weather[].description' <<< ${wea})"});
              f=(${(@f)"$(jq -r '.hourly[].dt' <<< ${wea} | awk '{print strftime("%H:%M",$1)}')"});
              a=(${(@F)$(seq 24)}); s=(${(@F)$(seq 48)}); s[1,24]=(); z=(${a:^s}); unset a s;
              for s in $z; do; a[++i]=${f[s]}" "${g[s]}" "${d[s]}; done; unset d;
              printf "%-28s%-28s\n" "Today" "Tomorrow" ${(@)a};
              return 0;
            fi;

            mkdir -p /tmp/wdr; cd /tmp/wdr;
            # 48 HOUR FORECAST
            jq -r '.hourly[].dt'         <<< ${wea} > dt48h;
            jq -r '.hourly[].temp'       <<< ${wea} > temp48h;
            jq -r '.hourly[].feels_like' <<< ${wea} > feels_like48h;
            jq -r '.hourly[].pressure'   <<< ${wea} > pressure48h;
            jq -r '.hourly[].humidity'   <<< ${wea} > humidity48h;
            jq -r '.hourly[].dew_point'  <<< ${wea} > dew_point48h;
            jq -r '.hourly[].clouds'     <<< ${wea} > clouds48h;
            jq -r '.hourly[].wind_speed' <<< ${wea} > wind_speed48h;
            jq -r '.hourly[].wind_deg'   <<< ${wea} > wind_deg48h;
            jq '.hourly[].rain | walk (if type == "null" then 0 else . end)' <<< ${wea} | sed -r '/\{|\}/d; s/ +"1h": //' > rain48h;
            jq '.hourly[].snow | walk (if type == "null" then 0 else . end)' <<< ${wea} | sed -r '/\{|\}/d; s/ +"1h": //' > snow48h;

            # 7 DAY FORECAST
            jq -r '.daily[].temp.min'         <<< ${wea} > min7d;
            jq -r '.daily[].temp.max'         <<< ${wea} > max7d;
            jq -r '.daily[].temp.day'         <<< ${wea} > day7d;
            jq -r '.daily[].temp.night'       <<< ${wea} > night7d;
            jq -r '.daily[].temp.eve'         <<< ${wea} > eve7d;
            jq -r '.daily[].temp.morn'        <<< ${wea} > morn7d;
            jq -r '.daily[].feels_like.day'   <<< ${wea} > flday7d;
            jq -r '.daily[].feels_like.night' <<< ${wea} > flnight7d;
            jq -r '.daily[].feels_like.eve'   <<< ${wea} > fleve7d;
            jq -r '.daily[].feels_like.morn'  <<< ${wea} > flmorn7d;
            jq -r '.daily[].pressure'         <<< ${wea} > pressure7d;
            jq -r '.daily[].humidity'         <<< ${wea} > humidity7d;
            jq -r '.daily[].clouds'           <<< ${wea} > clouds7d;
            jq -r '.daily[].dew_point'        <<< ${wea} > dew_point7d;
            jq -r '.daily[].wind_deg'         <<< ${wea} > wind_deg7d;
            jq -r '.daily[].wind_speed'       <<< ${wea} > wind_speed7d;
            jq -r '.daily[].rain | walk (if type == "null" then 0 else . end)' <<< ${wea} > rain7d;
            jq -r '.daily[].snow | walk (if type == "null" then 0 else . end)' <<< ${wea} > snow7d;

            octave-cli --persist ~/.config/zsh/other/wdr.m;
            # cd ~; rm -r ${tmp};
            # cd ~; rm -r /tmp/wdr;
            unalias fetch; break;;
          (q) return 1;; esac; done;;
    (2) # DARKSKY
      cd $(mktemp -d); local t=$(mktemp ./XXXXXXXX); local w=$(mktemp ./XXXXXXXX); local lon lat a s r c h d;
      r=${"$(stty size)"% *}; c=${"$(stty size)"#* };
      while true; do
        clear; box -H 1b -B 4 -T 3 -h darksky \
          "${(r.16...)$(<<< lon/lat:)}${lon:-42.6974} / ${lat:-23.3241}" \
          "${(r.16...)$(<<< location:)}${loc:-Sofia,Bulgaria}";
        menu -m 4b -t 2 '1 longitude / latitude' '2 location' '3 go' 'q quit';
        case $(read -sek1) in
          (1) read 'lon?lon: '; read 'lat?lat: '; if [[ ! ${lon} =~ '^\d+\.?\d\+$' ]] || [[ ! ${lat} =~ '^\d+\.?\d+$' ]]; then read -sek 'Invalid input!'; unset lon lat; return 1; fi;;
          (2) read 'loc?location: '; loc=${loc// /%20};;
          (3) if which curl &>/dev/null; then alias fetch="curl -s -f -L --max-redirs 0 -H 'User-Agent:' -o $t"; elif which wget &>/dev/null; then alias fetch="wget -q -O $t"; else return 1; fi;

            $(fetch https://darksky.net/details/${lon:-42.6974},${lat:-23.3241}/$(date +%F)/ca24/en) || return 1;
            [[ -z $t ]] && read -sk1 '?No data.' && return 1;
            pcre2grep -o1 '(\[.+)\]' $t >> $w; [[ -z $w ]] && read -sk1 '?fucked up json filter.' && return 1;

            h=$(date +%H);
            if [[ $h != 00 ]]; then
              printf '%s' ',' >> $w;
              $(fetch https://darksky.net/details/${lon:-42.6974},${lat:-23.3241}/$(date -d '+1day' +%F)/ca24/en) || return 1;
              [[ -z $t ]] && read -sk1 '?No data.' && return 1;
              pcre2grep -o1 '\[(.+\])' $t >> $w; [[ -z $w ]] && read -sk1 '?fucked up json filter.' && return 1;
            else printf '%s' ']' >> $w; fi;

            for a in ${(@f)"$(jq '.[].time' $w)"}; do s+=("$(date -d "1970-01-01 UTC $a seconds" +'%Y-%m-%d %H:%M')"); done;
            d=(${(@f)"$(jq -r '.[].summary' $w)"});
            print -C 2 ${s[1+$h,24+$h]} ${d[1+$h,24+$h]} > summary;
            for a in {1..$((r-${"$(wc -l summary)"%% *}))}; do printf '\n' >> summary; done;

            for a in ${(@f)"$(jq '.[1]' $w | pcre2grep -o1 '^\s+"(.+?)":' | pcre2grep -v '^(time|icon|summary|precipType|solar|azimuth|altitude|dni|ghi|dhi|etr)$')"}; do
              jq -r ".[range(1+$h;24+1+$h)].$a" $w | asciigraph -c $a -h $((r/2-2)) -w $((c-8)) > x.$a;
            done;

            cat summary x.*(.) | less; unalias fetch; break;;
          (q) return 1;;
        esac;
      done;;
    (q) return 0;;
    (*) return 1;;
  esac;
}