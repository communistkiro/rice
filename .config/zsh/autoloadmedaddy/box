#!/bin/zsh
function box () {
((# == 0)) && return 0;
typeset a h B T H ul ur dl dr uh dh lv rv r; integer s; s=1;
while getopts 's:h:B:T:H:' a; do case $a in
  (s) # line style
    s=$OPTARG;; 
  (h) # header
    h=$OPTARG;; 
  (B) # box color
    B="\033[;3$(pcre2grep -o1 '([0-7])' <<< $OPTARG || <<< 7)";
    [[ $OPTARG =~ i ]] && B="${B};7";
    [[ $OPTARG =~ b ]] && B="${B};1";
    B="${B}m";;
  (T) # text color
    T="\033[;3$(pcre2grep -o1 '([0-7])' <<< $OPTARG || <<< 7)";
    [[ $OPTARG =~ i ]] && T="${T};7";
    [[ $OPTARG =~ b ]] && T="${T};1";
    T="${T}m";;
  (H) # header color
    H="\033[;3$(pcre2grep -o1 '([0-7])' <<< $OPTARG || <<< 7)";
    [[ $OPTARG =~ i ]] && H="${H};7";
    [[ $OPTARG =~ b ]] && H="${H};1";
    H="${H}m";;
(*) less -F << HEREDOC # help wanted.
NAME
    box - enclose strings in box

SYNOPSIS
    box [-s 1--4] [-BTH [0-7]ib] [-h header] [string(s)]

DESCRIPTION
    box is a zsh script that encloses one or more strings, extending to 4 above the lengthiest 
    string, header included. The box's style is given by '-s', and may be thick, thin, double, 
    or dotted; may have a title; and may color the box's line, text, and header in different 
    colors according to ANSI C escape codes. The color is a 1--3-character sequence of a number 
    0--7,'b' for bold color, and 'i' to switch fore- and background colors. The number 
    corresponding to the colors black, red, green, yellow, blue, magenta, cyan, and white. 
    Defaults to thick lines and white for box, text, and header. Don't use = for options 
    accepting arguments.

EXAMPLES
    box -h header 'This is a sentence on the first row' 'This is a second row'
    a=Zz; box -s 3 -T 3b -B b2 -H 5i -h 'looooooooooooooooong snooze' ${(pr.16..$a.l.8...)a} "padding works, too"

HEREDOC
;; esac; done;

ul=(┏ ┌ ╔ ⡏); ul=${ul[$s]};
dl=(┗ └ ╚ ⣇); dl=${dl[$s]};
ur=(┓ ┐ ╗ ⢹); ur=${ur[$s]};
dr=(┛ ┘ ╝ ⣸); dr=${dr[$s]};
uh=(━ ─ ═ ⠉); uh=${uh[$s]};
dh=(━ ─ ═ ⣀); dh=${dh[$s]};
lv=(┃ │ ║ ⡇); lv=${lv[$s]};
rv=(┃ │ ║ ⢸); rv=${rv[$s]};

s=0; for a in $@[OPTIND,-1]; do ((${(c)#a} > $s)) && s=${(c)#a}; done;
if ((${+h})) && (($#h > $s)); then s=$#h; ((s+=2)); fi; ((s+=2)); 

((${+h})) && printf '%b\n' "$B$ul${(pr.(((s-$#h)/2))..$uh.)uh}$r$H$h$r$B${(pr.(((s-$#h)/2+$#h+s-($#h+s)/2*2))..$uh.)uh}$ur" || printf '%b\n' "$B$ul${(pr.((s-1))..$uh.)uh}$ur";

for a in $@[OPTIND,-1]; do printf '%b\n' "$lv $r$T${(r.((s-2)).. .)a} $r$B$rv"; done;

printf '%b\n' "$dl${(pr.$s..$dh.)dh}$dr$r";
}
